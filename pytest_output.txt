============================= test session starts =============================
platform win32 -- Python 3.13.5, pytest-8.4.1, pluggy-1.6.0
rootdir: D:\Python Projetos\detective_ai
plugins: anyio-4.9.0, asyncio-1.1.0
asyncio: mode=Mode.STRICT, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 1 item

tests\test_happy_path_flow.py F                                          [100%]

================================== FAILURES ===================================
______________________ test_happy_path_piloto_end_to_end ______________________

    def test_happy_path_piloto_end_to_end():
    
        SessionLocal = patch_db_to_memory_sqlite()
    
        # -------------------------
        # 1. Carregar cenßrio piloto
        # -------------------------
        db = SessionLocal()
        try:
            scenario_path = os.path.join("scenarios", "piloto.json")
            assert os.path.exists(scenario_path), "piloto.json nÒo encontrado"
    
            load_scenario_from_json(scenario_path, db=db)
    
            scenario = db.query(ScenarioModel).first()
            assert scenario is not None
    
            marina = db.query(SuspectModel).filter(
                SuspectModel.name == "Marina Souza"
            ).first()
            assert marina is not None
    
            evidence_relatorio = db.query(EvidenceModel).filter(
                EvidenceModel.name == "Relat¾rio Contßbil Alterado"
            ).first()
    
            evidence_cartao = db.query(EvidenceModel).filter(
                EvidenceModel.name == "CartÒo de Acesso de Marina"
            ).first()
    
            evidence_testemunho = db.query(EvidenceModel).filter(
                EvidenceModel.name == "Testemunho da Estagißria"
            ).first()
    
            mandatory_ids = scenario.required_evidence_ids
    
        finally:
            db.close()
    
        client = TestClient(app)
    
        # -------------------------
        # 2. Criar sessÒo
        # -------------------------
        resp = client.post("/sessions", json={"scenario_id": scenario.id})
        assert resp.status_code == 200
        session_id = resp.json()["session_id"]
    
        # -------------------------
        # 3. Confrontos
        # -------------------------
>       client.post(
            f"/sessions/{session_id}/suspects/{marina.id}/messages",
            json={"text": "Explique isso.", "evidence_id": evidence_relatorio.id}
        )

tests\test_happy_path_flow.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <starlette.testclient.TestClient object at 0x00000252F4CA6510>
url = '/sessions/1/suspects/1/messages'

    def post(  # type: ignore[override]
        self,
        url: httpx._types.URLTypes,
        *,
        content: httpx._types.RequestContent | None = None,
        data: _RequestData | None = None,
        files: httpx._types.RequestFiles | None = None,
        json: Any = None,
        params: httpx._types.QueryParamTypes | None = None,
        headers: httpx._types.HeaderTypes | None = None,
        cookies: httpx._types.CookieTypes | None = None,
        auth: httpx._types.AuthTypes | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,
        follow_redirects: bool | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,
        timeout: httpx._types.TimeoutTypes | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,
        extensions: dict[str, Any] | None = None,
    ) -> httpx.Response:
>       return super().post(
            url,
            content=content,
            data=data,
            files=files,
            json=json,
            params=params,
            headers=headers,
            cookies=cookies,
            auth=auth,
            follow_redirects=follow_redirects,
            timeout=timeout,
            extensions=extensions,
        )

C:\Users\Filipe AtaÝde\AppData\Local\Programs\Python\Python313\Lib\site-packages\starlette\testclient.py:552: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <starlette.testclient.TestClient object at 0x00000252F4CA6510>
url = '/sessions/1/suspects/1/messages'

    def post(
        self,
        url: URL | str,
        *,
        content: RequestContent | None = None,
        data: RequestData | None = None,
        files: RequestFiles | None = None,
        json: typing.Any | None = None,
        params: QueryParamTypes | None = None,
        headers: HeaderTypes | None = None,
        cookies: CookieTypes | None = None,
        auth: AuthTypes | UseClientDefault = USE_CLIENT_DEFAULT,
        follow_redirects: bool | UseClientDefault = USE_CLIENT_DEFAULT,
        timeout: TimeoutTypes | UseClientDefault = USE_CLIENT_DEFAULT,
        extensions: RequestExtensions | None = None,
    ) -> Response:
        """
        Send a `POST` request.
    
        **Parameters**: See `httpx.request`.
        """
>       return self.request(
            "POST",
            url,
            content=content,
            data=data,
            files=files,
            json=json,
            params=params,
            headers=headers,
            cookies=cookies,
            auth=auth,
            follow_redirects=follow_redirects,
            timeout=timeout,
            extensions=extensions,
        )

C:\Users\Filipe AtaÝde\AppData\Local\Programs\Python\Python313\Lib\site-packages\httpx\_client.py:1144: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <starlette.testclient.TestClient object at 0x00000252F4CA6510>
method = 'POST', url = URL('http://testserver/sessions/1/suspects/1/messages')

    def request(  # type: ignore[override]
        self,
        method: str,
        url: httpx._types.URLTypes,
        *,
        content: httpx._types.RequestContent | None = None,
        data: _RequestData | None = None,
        files: httpx._types.RequestFiles | None = None,
        json: Any = None,
        params: httpx._types.QueryParamTypes | None = None,
        headers: httpx._types.HeaderTypes | None = None,
        cookies: httpx._types.CookieTypes | None = None,
        auth: httpx._types.AuthTypes | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,
        follow_redirects: bool | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,
        timeout: httpx._types.TimeoutTypes | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,
        extensions: dict[str, Any] | None = None,
    ) -> httpx.Response:
        if timeout is not httpx.USE_CLIENT_DEFAULT:
            warnings.warn(
                "You should not use the 'timeout' argument with the TestClient. "
                "See https://github.com/encode/starlette/issues/1108 for more information.",
                DeprecationWarning,
            )
        url = self._merge_url(url)
>       return super().request(
            method,
            url,
            content=content,
            data=data,
            files=files,
            json=json,
            params=params,
            headers=headers,
            cookies=cookies,
            auth=auth,
            follow_redirects=follow_redirects,
            timeout=timeout,
            extensions=extensions,
        )

C:\Users\Filipe AtaÝde\AppData\Local\Programs\Python\Python313\Lib\site-packages\starlette\testclient.py:451: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <starlette.testclient.TestClient object at 0x00000252F4CA6510>
method = 'POST', url = URL('http://testserver/sessions/1/suspects/1/messages')

    def request(
        self,
        method: str,
        url: URL | str,
        *,
        content: RequestContent | None = None,
        data: RequestData | None = None,
        files: RequestFiles | None = None,
        json: typing.Any | None = None,
        params: QueryParamTypes | None = None,
        headers: HeaderTypes | None = None,
        cookies: CookieTypes | None = None,
        auth: AuthTypes | UseClientDefault | None = USE_CLIENT_DEFAULT,
        follow_redirects: bool | UseClientDefault = USE_CLIENT_DEFAULT,
        timeout: TimeoutTypes | UseClientDefault = USE_CLIENT_DEFAULT,
        extensions: RequestExtensions | None = None,
    ) -> Response:
        """
        Build and send a request.
    
        Equivalent to:
    
        ```python
        request = client.build_request(...)
        response = client.send(request, ...)
        ```
    
        See `Client.build_request()`, `Client.send()` and
        [Merging of configuration][0] for how the various parameters
        are merged with client-level configuration.
    
        [0]: /advanced/clients/#merging-of-configuration
        """
        if cookies is not None:
            message = (
                "Setting per-request cookies=<...> is being deprecated, because "
                "the expected behaviour on cookie persistence is ambiguous. Set "
                "cookies directly on the client instance instead."
            )
            warnings.warn(message, DeprecationWarning, stacklevel=2)
    
        request = self.build_request(
            method=method,
            url=url,
            content=content,
            data=data,
            files=files,
            json=json,
            params=params,
            headers=headers,
            cookies=cookies,
            timeout=timeout,
            extensions=extensions,
        )
>       return self.send(request, auth=auth, follow_redirects=follow_redirects)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

C:\Users\Filipe AtaÝde\AppData\Local\Programs\Python\Python313\Lib\site-packages\httpx\_client.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <starlette.testclient.TestClient object at 0x00000252F4CA6510>
request = <Request('POST', 'http://testserver/sessions/1/suspects/1/messages')>

    def send(
        self,
        request: Request,
        *,
        stream: bool = False,
        auth: AuthTypes | UseClientDefault | None = USE_CLIENT_DEFAULT,
        follow_redirects: bool | UseClientDefault = USE_CLIENT_DEFAULT,
    ) -> Response:
        """
        Send a request.
    
        The request is sent as-is, unmodified.
    
        Typically you'll want to build one with `Client.build_request()`
        so that any client-level configuration is merged into the request,
        but passing an explicit `httpx.Request()` is supported as well.
    
        See also: [Request instances][0]
    
        [0]: /advanced/clients/#request-instances
        """
        if self._state == ClientState.CLOSED:
            raise RuntimeError("Cannot send a request, as the client has been closed.")
    
        self._state = ClientState.OPENED
        follow_redirects = (
            self.follow_redirects
            if isinstance(follow_redirects, UseClientDefault)
            else follow_redirects
        )
    
        self._set_timeout(request)
    
        auth = self._build_request_auth(request, auth)
    
>       response = self._send_handling_auth(
            request,
            auth=auth,
            follow_redirects=follow_redirects,
            history=[],
        )

C:\Users\Filipe AtaÝde\AppData\Local\Programs\Python\Python313\Lib\site-packages\httpx\_client.py:914: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <starlette.testclient.TestClient object at 0x00000252F4CA6510>
request = <Request('POST', 'http://testserver/sessions/1/suspects/1/messages')>
auth = <httpx.Auth object at 0x00000252F4E5D450>, follow_redirects = True
history = []

    def _send_handling_auth(
        self,
        request: Request,
        auth: Auth,
        follow_redirects: bool,
        history: list[Response],
    ) -> Response:
        auth_flow = auth.sync_auth_flow(request)
        try:
            request = next(auth_flow)
    
            while True:
>               response = self._send_handling_redirects(
                    request,
                    follow_redirects=follow_redirects,
                    history=history,
                )

C:\Users\Filipe AtaÝde\AppData\Local\Programs\Python\Python313\Lib\site-packages\httpx\_client.py:942: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <starlette.testclient.TestClient object at 0x00000252F4CA6510>
request = <Request('POST', 'http://testserver/sessions/1/suspects/1/messages')>
follow_redirects = True, history = []

    def _send_handling_redirects(
        self,
        request: Request,
        follow_redirects: bool,
        history: list[Response],
    ) -> Response:
        while True:
            if len(history) > self.max_redirects:
                raise TooManyRedirects(
                    "Exceeded maximum allowed redirects.", request=request
                )
    
            for hook in self._event_hooks["request"]:
                hook(request)
    
>           response = self._send_single_request(request)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

C:\Users\Filipe AtaÝde\AppData\Local\Programs\Python\Python313\Lib\site-packages\httpx\_client.py:979: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <starlette.testclient.TestClient object at 0x00000252F4CA6510>
request = <Request('POST', 'http://testserver/sessions/1/suspects/1/messages')>

    def _send_single_request(self, request: Request) -> Response:
        """
        Sends a single request, without handling any redirections.
        """
        transport = self._transport_for_url(request.url)
        start = time.perf_counter()
    
        if not isinstance(request.stream, SyncByteStream):
            raise RuntimeError(
                "Attempted to send an async request with a sync Client instance."
            )
    
        with request_context(request=request):
>           response = transport.handle_request(request)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

C:\Users\Filipe AtaÝde\AppData\Local\Programs\Python\Python313\Lib\site-packages\httpx\_client.py:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <starlette.testclient._TestClientTransport object at 0x00000252F4CA7620>
request = <Request('POST', 'http://testserver/sessions/1/suspects/1/messages')>

    def handle_request(self, request: httpx.Request) -> httpx.Response:
        scheme = request.url.scheme
        netloc = request.url.netloc.decode(encoding="ascii")
        path = request.url.path
        raw_path = request.url.raw_path
        query = request.url.query.decode(encoding="ascii")
    
        default_port = {"http": 80, "ws": 80, "https": 443, "wss": 443}[scheme]
    
        if ":" in netloc:
            host, port_string = netloc.split(":", 1)
            port = int(port_string)
        else:
            host = netloc
            port = default_port
    
        # Include the 'host' header.
        if "host" in request.headers:
            headers: list[tuple[bytes, bytes]] = []
        elif port == default_port:  # pragma: no cover
            headers = [(b"host", host.encode())]
        else:  # pragma: no cover
            headers = [(b"host", (f"{host}:{port}").encode())]
    
        # Include other request headers.
        headers += [(key.lower().encode(), value.encode()) for key, value in request.headers.multi_items()]
    
        scope: dict[str, Any]
    
        if scheme in {"ws", "wss"}:
            subprotocol = request.headers.get("sec-websocket-protocol", None)
            if subprotocol is None:
                subprotocols: Sequence[str] = []
            else:
                subprotocols = [value.strip() for value in subprotocol.split(",")]
            scope = {
                "type": "websocket",
                "path": unquote(path),
                "raw_path": raw_path.split(b"?", 1)[0],
                "root_path": self.root_path,
                "scheme": scheme,
                "query_string": query.encode(),
                "headers": headers,
                "client": self.client,
                "server": [host, port],
                "subprotocols": subprotocols,
                "state": self.app_state.copy(),
                "extensions": {"websocket.http.response": {}},
            }
            session = WebSocketTestSession(self.app, scope, self.portal_factory)
            raise _Upgrade(session)
    
        scope = {
            "type": "http",
            "http_version": "1.1",
            "method": request.method,
            "path": unquote(path),
            "raw_path": raw_path.split(b"?", 1)[0],
            "root_path": self.root_path,
            "scheme": scheme,
            "query_string": query.encode(),
            "headers": headers,
            "client": self.client,
            "server": [host, port],
            "extensions": {"http.response.debug": {}},
            "state": self.app_state.copy(),
        }
    
        request_complete = False
        response_started = False
        response_complete: anyio.Event
        raw_kwargs: dict[str, Any] = {"stream": io.BytesIO()}
        template = None
        context = None
    
        async def receive() -> Message:
            nonlocal request_complete
    
            if request_complete:
                if not response_complete.is_set():
                    await response_complete.wait()
                return {"type": "http.disconnect"}
    
            body = request.read()
            if isinstance(body, str):
                body_bytes: bytes = body.encode("utf-8")  # pragma: no cover
            elif body is None:
                body_bytes = b""  # pragma: no cover
            elif isinstance(body, GeneratorType):
                try:  # pragma: no cover
                    chunk = body.send(None)
                    if isinstance(chunk, str):
                        chunk = chunk.encode("utf-8")
                    return {"type": "http.request", "body": chunk, "more_body": True}
                except StopIteration:  # pragma: no cover
                    request_complete = True
                    return {"type": "http.request", "body": b""}
            else:
                body_bytes = body
    
            request_complete = True
            return {"type": "http.request", "body": body_bytes}
    
        async def send(message: Message) -> None:
            nonlocal raw_kwargs, response_started, template, context
    
            if message["type"] == "http.response.start":
                assert not response_started, 'Received multiple "http.response.start" messages.'
                raw_kwargs["status_code"] = message["status"]
                raw_kwargs["headers"] = [(key.decode(), value.decode()) for key, value in message.get("headers", [])]
                response_started = True
            elif message["type"] == "http.response.body":
                assert response_started, 'Received "http.response.body" without "http.response.start".'
                assert not response_complete.is_set(), 'Received "http.response.body" after response completed.'
                body = message.get("body", b"")
                more_body = message.get("more_body", False)
                if request.method != "HEAD":
                    raw_kwargs["stream"].write(body)
                if not more_body:
                    raw_kwargs["stream"].seek(0)
                    response_complete.set()
            elif message["type"] == "http.response.debug":
                template = message["info"]["template"]
                context = message["info"]["context"]
    
        try:
            with self.portal_factory() as portal:
                response_complete = portal.call(anyio.Event)
                portal.call(self.app, scope, receive, send)
        except BaseException as exc:
            if self.raise_server_exceptions:
>               raise exc

C:\Users\Filipe AtaÝde\AppData\Local\Programs\Python\Python313\Lib\site-packages\starlette\testclient.py:354: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <starlette.testclient._TestClientTransport object at 0x00000252F4CA7620>
request = <Request('POST', 'http://testserver/sessions/1/suspects/1/messages')>

    def handle_request(self, request: httpx.Request) -> httpx.Response:
        scheme = request.url.scheme
        netloc = request.url.netloc.decode(encoding="ascii")
        path = request.url.path
        raw_path = request.url.raw_path
        query = request.url.query.decode(encoding="ascii")
    
        default_port = {"http": 80, "ws": 80, "https": 443, "wss": 443}[scheme]
    
        if ":" in netloc:
            host, port_string = netloc.split(":", 1)
            port = int(port_string)
        else:
            host = netloc
            port = default_port
    
        # Include the 'host' header.
        if "host" in request.headers:
            headers: list[tuple[bytes, bytes]] = []
        elif port == default_port:  # pragma: no cover
            headers = [(b"host", host.encode())]
        else:  # pragma: no cover
            headers = [(b"host", (f"{host}:{port}").encode())]
    
        # Include other request headers.
        headers += [(key.lower().encode(), value.encode()) for key, value in request.headers.multi_items()]
    
        scope: dict[str, Any]
    
        if scheme in {"ws", "wss"}:
            subprotocol = request.headers.get("sec-websocket-protocol", None)
            if subprotocol is None:
                subprotocols: Sequence[str] = []
            else:
                subprotocols = [value.strip() for value in subprotocol.split(",")]
            scope = {
                "type": "websocket",
                "path": unquote(path),
                "raw_path": raw_path.split(b"?", 1)[0],
                "root_path": self.root_path,
                "scheme": scheme,
                "query_string": query.encode(),
                "headers": headers,
                "client": self.client,
                "server": [host, port],
                "subprotocols": subprotocols,
                "state": self.app_state.copy(),
                "extensions": {"websocket.http.response": {}},
            }
            session = WebSocketTestSession(self.app, scope, self.portal_factory)
            raise _Upgrade(session)
    
        scope = {
            "type": "http",
            "http_version": "1.1",
            "method": request.method,
            "path": unquote(path),
            "raw_path": raw_path.split(b"?", 1)[0],
            "root_path": self.root_path,
            "scheme": scheme,
            "query_string": query.encode(),
            "headers": headers,
            "client": self.client,
            "server": [host, port],
            "extensions": {"http.response.debug": {}},
            "state": self.app_state.copy(),
        }
    
        request_complete = False
        response_started = False
        response_complete: anyio.Event
        raw_kwargs: dict[str, Any] = {"stream": io.BytesIO()}
        template = None
        context = None
    
        async def receive() -> Message:
            nonlocal request_complete
    
            if request_complete:
                if not response_complete.is_set():
                    await response_complete.wait()
                return {"type": "http.disconnect"}
    
            body = request.read()
            if isinstance(body, str):
                body_bytes: bytes = body.encode("utf-8")  # pragma: no cover
            elif body is None:
                body_bytes = b""  # pragma: no cover
            elif isinstance(body, GeneratorType):
                try:  # pragma: no cover
                    chunk = body.send(None)
                    if isinstance(chunk, str):
                        chunk = chunk.encode("utf-8")
                    return {"type": "http.request", "body": chunk, "more_body": True}
                except StopIteration:  # pragma: no cover
                    request_complete = True
                    return {"type": "http.request", "body": b""}
            else:
                body_bytes = body
    
            request_complete = True
            return {"type": "http.request", "body": body_bytes}
    
        async def send(message: Message) -> None:
            nonlocal raw_kwargs, response_started, template, context
    
            if message["type"] == "http.response.start":
                assert not response_started, 'Received multiple "http.response.start" messages.'
                raw_kwargs["status_code"] = message["status"]
                raw_kwargs["headers"] = [(key.decode(), value.decode()) for key, value in message.get("headers", [])]
                response_started = True
            elif message["type"] == "http.response.body":
                assert response_started, 'Received "http.response.body" without "http.response.start".'
                assert not response_complete.is_set(), 'Received "http.response.body" after response completed.'
                body = message.get("body", b"")
                more_body = message.get("more_body", False)
                if request.method != "HEAD":
                    raw_kwargs["stream"].write(body)
                if not more_body:
                    raw_kwargs["stream"].seek(0)
                    response_complete.set()
            elif message["type"] == "http.response.debug":
                template = message["info"]["template"]
                context = message["info"]["context"]
    
        try:
            with self.portal_factory() as portal:
                response_complete = portal.call(anyio.Event)
>               portal.call(self.app, scope, receive, send)

C:\Users\Filipe AtaÝde\AppData\Local\Programs\Python\Python313\Lib\site-packages\starlette\testclient.py:351: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <anyio._backends._asyncio.BlockingPortal object at 0x00000252F4E5D810>
func = <fastapi.applications.FastAPI object at 0x00000252F4CA5940>
args = ({'app': <fastapi.applications.FastAPI object at 0x00000252F4CA5940>, 'client': ('testclient', 50000), 'endpoint': <fu...ls>.receive at 0x00000252F4E3FCE0>, <function _TestClientTransport.handle_request.<locals>.send at 0x00000252F4E3FBA0>)

    def call(
        self,
        func: Callable[[Unpack[PosArgsT]], Awaitable[T_Retval] | T_Retval],
        *args: Unpack[PosArgsT],
    ) -> T_Retval:
        """
        Call the given function in the event loop thread.
    
        If the callable returns a coroutine object, it is awaited on.
    
        :param func: any callable
        :raises RuntimeError: if the portal is not running or if this method is called
            from within the event loop thread
    
        """
>       return cast(T_Retval, self.start_task_soon(func, *args).result())
                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

C:\Users\Filipe AtaÝde\AppData\Local\Programs\Python\Python313\Lib\site-packages\anyio\from_thread.py:290: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = None, timeout = None

    def result(self, timeout=None):
        """Return the result of the call that the future represents.
    
        Args:
            timeout: The number of seconds to wait for the result if the future
                isn't done. If None, then there is no limit on the wait time.
    
        Returns:
            The result of the call that the future represents.
    
        Raises:
            CancelledError: If the future was cancelled.
            TimeoutError: If the future didn't finish executing before the given
                timeout.
            Exception: If the call raised then that exception will be raised.
        """
        try:
            with self._condition:
                if self._state in [CANCELLED, CANCELLED_AND_NOTIFIED]:
                    raise CancelledError()
                elif self._state == FINISHED:
                    return self.__get_result()
    
                self._condition.wait(timeout)
    
                if self._state in [CANCELLED, CANCELLED_AND_NOTIFIED]:
                    raise CancelledError()
                elif self._state == FINISHED:
>                   return self.__get_result()
                           ^^^^^^^^^^^^^^^^^^^

C:\Users\Filipe AtaÝde\AppData\Local\Programs\Python\Python313\Lib\concurrent\futures\_base.py:456: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = None

    def __get_result(self):
        if self._exception is not None:
            try:
>               raise self._exception

C:\Users\Filipe AtaÝde\AppData\Local\Programs\Python\Python313\Lib\concurrent\futures\_base.py:401: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <anyio._backends._asyncio.BlockingPortal object at 0x00000252F4E5D810>
func = <fastapi.applications.FastAPI object at 0x00000252F4CA5940>
args = ({'app': <fastapi.applications.FastAPI object at 0x00000252F4CA5940>, 'client': ('testclient', 50000), 'endpoint': <fu...ls>.receive at 0x00000252F4E3FCE0>, <function _TestClientTransport.handle_request.<locals>.send at 0x00000252F4E3FBA0>)
kwargs = {}, future = <Future at 0x252f4e6c500 state=finished raised NameError>

    async def _call_func(
        self,
        func: Callable[[Unpack[PosArgsT]], Awaitable[T_Retval] | T_Retval],
        args: tuple[Unpack[PosArgsT]],
        kwargs: dict[str, Any],
        future: Future[T_Retval],
    ) -> None:
        def callback(f: Future[T_Retval]) -> None:
            if f.cancelled() and self._event_loop_thread_id not in (
                None,
                get_ident(),
            ):
                self.call(scope.cancel)
    
        try:
            retval_or_awaitable = func(*args, **kwargs)
            if isawaitable(retval_or_awaitable):
                with CancelScope() as scope:
                    if future.cancelled():
                        scope.cancel()
                    else:
                        future.add_done_callback(callback)
    
>                   retval = await retval_or_awaitable
                             ^^^^^^^^^^^^^^^^^^^^^^^^^

C:\Users\Filipe AtaÝde\AppData\Local\Programs\Python\Python313\Lib\site-packages\anyio\from_thread.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <fastapi.applications.FastAPI object at 0x00000252F4CA5940>
scope = {'app': <fastapi.applications.FastAPI object at 0x00000252F4CA5940>, 'client': ('testclient', 50000), 'endpoint': <function send_message_to_suspect at 0x00000252F4C96DE0>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function _TestClientTransport.handle_request.<locals>.receive at 0x00000252F4E3FCE0>
send = <function _TestClientTransport.handle_request.<locals>.send at 0x00000252F4E3FBA0>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        if self.root_path:
            scope["root_path"] = self.root_path
>       await super().__call__(scope, receive, send)

C:\Users\Filipe AtaÝde\AppData\Local\Programs\Python\Python313\Lib\site-packages\fastapi\applications.py:1133: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <fastapi.applications.FastAPI object at 0x00000252F4CA5940>
scope = {'app': <fastapi.applications.FastAPI object at 0x00000252F4CA5940>, 'client': ('testclient', 50000), 'endpoint': <function send_message_to_suspect at 0x00000252F4C96DE0>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function _TestClientTransport.handle_request.<locals>.receive at 0x00000252F4E3FCE0>
send = <function _TestClientTransport.handle_request.<locals>.send at 0x00000252F4E3FBA0>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        scope["app"] = self
        if self.middleware_stack is None:
            self.middleware_stack = self.build_middleware_stack()
>       await self.middleware_stack(scope, receive, send)

C:\Users\Filipe AtaÝde\AppData\Local\Programs\Python\Python313\Lib\site-packages\starlette\applications.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <starlette.middleware.errors.ServerErrorMiddleware object at 0x00000252F4E96510>
scope = {'app': <fastapi.applications.FastAPI object at 0x00000252F4CA5940>, 'client': ('testclient', 50000), 'endpoint': <function send_message_to_suspect at 0x00000252F4C96DE0>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function _TestClientTransport.handle_request.<locals>.receive at 0x00000252F4E3FCE0>
send = <function _TestClientTransport.handle_request.<locals>.send at 0x00000252F4E3FBA0>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        if scope["type"] != "http":
            await self.app(scope, receive, send)
            return
    
        response_started = False
    
        async def _send(message: Message) -> None:
            nonlocal response_started, send
    
            if message["type"] == "http.response.start":
                response_started = True
            await send(message)
    
        try:
            await self.app(scope, receive, _send)
        except Exception as exc:
            request = Request(scope)
            if self.debug:
                # In debug mode, return traceback responses.
                response = self.debug_response(request, exc)
            elif self.handler is None:
                # Use our default 500 error handler.
                response = self.error_response(request, exc)
            else:
                # Use an installed 500 error handler.
                if is_async_callable(self.handler):
                    response = await self.handler(request, exc)
                else:
                    response = await run_in_threadpool(self.handler, request, exc)
    
            if not response_started:
                await response(scope, receive, send)
    
            # We always continue to raise the exception.
            # This allows servers to log the error, or allows test clients
            # to optionally raise the error within the test case.
>           raise exc

C:\Users\Filipe AtaÝde\AppData\Local\Programs\Python\Python313\Lib\site-packages\starlette\middleware\errors.py:186: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <starlette.middleware.errors.ServerErrorMiddleware object at 0x00000252F4E96510>
scope = {'app': <fastapi.applications.FastAPI object at 0x00000252F4CA5940>, 'client': ('testclient', 50000), 'endpoint': <function send_message_to_suspect at 0x00000252F4C96DE0>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function _TestClientTransport.handle_request.<locals>.receive at 0x00000252F4E3FCE0>
send = <function _TestClientTransport.handle_request.<locals>.send at 0x00000252F4E3FBA0>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        if scope["type"] != "http":
            await self.app(scope, receive, send)
            return
    
        response_started = False
    
        async def _send(message: Message) -> None:
            nonlocal response_started, send
    
            if message["type"] == "http.response.start":
                response_started = True
            await send(message)
    
        try:
>           await self.app(scope, receive, _send)

C:\Users\Filipe AtaÝde\AppData\Local\Programs\Python\Python313\Lib\site-packages\starlette\middleware\errors.py:164: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <starlette.middleware.exceptions.ExceptionMiddleware object at 0x00000252F4E96120>
scope = {'app': <fastapi.applications.FastAPI object at 0x00000252F4CA5940>, 'client': ('testclient', 50000), 'endpoint': <function send_message_to_suspect at 0x00000252F4C96DE0>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function _TestClientTransport.handle_request.<locals>.receive at 0x00000252F4E3FCE0>
send = <function ServerErrorMiddleware.__call__.<locals>._send at 0x00000252F4EE3380>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        if scope["type"] not in ("http", "websocket"):
            await self.app(scope, receive, send)
            return
    
        scope["starlette.exception_handlers"] = (
            self._exception_handlers,
            self._status_handlers,
        )
    
        conn: Request | WebSocket
        if scope["type"] == "http":
            conn = Request(scope, receive, send)
        else:
            conn = WebSocket(scope, receive, send)
    
>       await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)

C:\Users\Filipe AtaÝde\AppData\Local\Programs\Python\Python313\Lib\site-packages\starlette\middleware\exceptions.py:63: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

scope = {'app': <fastapi.applications.FastAPI object at 0x00000252F4CA5940>, 'client': ('testclient', 50000), 'endpoint': <function send_message_to_suspect at 0x00000252F4C96DE0>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function _TestClientTransport.handle_request.<locals>.receive at 0x00000252F4E3FCE0>
send = <function ServerErrorMiddleware.__call__.<locals>._send at 0x00000252F4EE3380>

    async def wrapped_app(scope: Scope, receive: Receive, send: Send) -> None:
        response_started = False
    
        async def sender(message: Message) -> None:
            nonlocal response_started
    
            if message["type"] == "http.response.start":
                response_started = True
            await send(message)
    
        try:
            await app(scope, receive, sender)
        except Exception as exc:
            handler = None
    
            if isinstance(exc, HTTPException):
                handler = status_handlers.get(exc.status_code)
    
            if handler is None:
                handler = _lookup_exception_handler(exception_handlers, exc)
    
            if handler is None:
>               raise exc

C:\Users\Filipe AtaÝde\AppData\Local\Programs\Python\Python313\Lib\site-packages\starlette\_exception_handler.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

scope = {'app': <fastapi.applications.FastAPI object at 0x00000252F4CA5940>, 'client': ('testclient', 50000), 'endpoint': <function send_message_to_suspect at 0x00000252F4C96DE0>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function _TestClientTransport.handle_request.<locals>.receive at 0x00000252F4E3FCE0>
send = <function ServerErrorMiddleware.__call__.<locals>._send at 0x00000252F4EE3380>

    async def wrapped_app(scope: Scope, receive: Receive, send: Send) -> None:
        response_started = False
    
        async def sender(message: Message) -> None:
            nonlocal response_started
    
            if message["type"] == "http.response.start":
                response_started = True
            await send(message)
    
        try:
>           await app(scope, receive, sender)

C:\Users\Filipe AtaÝde\AppData\Local\Programs\Python\Python313\Lib\site-packages\starlette\_exception_handler.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <fastapi.middleware.asyncexitstack.AsyncExitStackMiddleware object at 0x00000252F4E963C0>
scope = {'app': <fastapi.applications.FastAPI object at 0x00000252F4CA5940>, 'client': ('testclient', 50000), 'endpoint': <function send_message_to_suspect at 0x00000252F4C96DE0>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function _TestClientTransport.handle_request.<locals>.receive at 0x00000252F4E3FCE0>
send = <function wrap_app_handling_exceptions.<locals>.wrapped_app.<locals>.sender at 0x00000252F4EE3600>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        async with AsyncExitStack() as stack:
            scope[self.context_name] = stack
>           await self.app(scope, receive, send)

C:\Users\Filipe AtaÝde\AppData\Local\Programs\Python\Python313\Lib\site-packages\fastapi\middleware\asyncexitstack.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <fastapi.routing.APIRouter object at 0x00000252F4B05810>
scope = {'app': <fastapi.applications.FastAPI object at 0x00000252F4CA5940>, 'client': ('testclient', 50000), 'endpoint': <function send_message_to_suspect at 0x00000252F4C96DE0>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function _TestClientTransport.handle_request.<locals>.receive at 0x00000252F4E3FCE0>
send = <function wrap_app_handling_exceptions.<locals>.wrapped_app.<locals>.sender at 0x00000252F4EE3600>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        """
        The main entry point to the Router class.
        """
>       await self.middleware_stack(scope, receive, send)

C:\Users\Filipe AtaÝde\AppData\Local\Programs\Python\Python313\Lib\site-packages\starlette\routing.py:716: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <fastapi.routing.APIRouter object at 0x00000252F4B05810>
scope = {'app': <fastapi.applications.FastAPI object at 0x00000252F4CA5940>, 'client': ('testclient', 50000), 'endpoint': <function send_message_to_suspect at 0x00000252F4C96DE0>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function _TestClientTransport.handle_request.<locals>.receive at 0x00000252F4E3FCE0>
send = <function wrap_app_handling_exceptions.<locals>.wrapped_app.<locals>.sender at 0x00000252F4EE3600>

    async def app(self, scope: Scope, receive: Receive, send: Send) -> None:
        assert scope["type"] in ("http", "websocket", "lifespan")
    
        if "router" not in scope:
            scope["router"] = self
    
        if scope["type"] == "lifespan":
            await self.lifespan(scope, receive, send)
            return
    
        partial = None
    
        for route in self.routes:
            # Determine if any route matches the incoming scope,
            # and hand over to the matching route if found.
            match, child_scope = route.matches(scope)
            if match == Match.FULL:
                scope.update(child_scope)
>               await route.handle(scope, receive, send)

C:\Users\Filipe AtaÝde\AppData\Local\Programs\Python\Python313\Lib\site-packages\starlette\routing.py:736: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = APIRoute(path='/sessions/{session_id}/suspects/{suspect_id}/messages', name='send_message_to_suspect', methods=['POST'])
scope = {'app': <fastapi.applications.FastAPI object at 0x00000252F4CA5940>, 'client': ('testclient', 50000), 'endpoint': <function send_message_to_suspect at 0x00000252F4C96DE0>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function _TestClientTransport.handle_request.<locals>.receive at 0x00000252F4E3FCE0>
send = <function wrap_app_handling_exceptions.<locals>.wrapped_app.<locals>.sender at 0x00000252F4EE3600>

    async def handle(self, scope: Scope, receive: Receive, send: Send) -> None:
        if self.methods and scope["method"] not in self.methods:
            headers = {"Allow": ", ".join(self.methods)}
            if "app" in scope:
                raise HTTPException(status_code=405, headers=headers)
            else:
                response = PlainTextResponse("Method Not Allowed", status_code=405, headers=headers)
            await response(scope, receive, send)
        else:
>           await self.app(scope, receive, send)

C:\Users\Filipe AtaÝde\AppData\Local\Programs\Python\Python313\Lib\site-packages\starlette\routing.py:290: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

scope = {'app': <fastapi.applications.FastAPI object at 0x00000252F4CA5940>, 'client': ('testclient', 50000), 'endpoint': <function send_message_to_suspect at 0x00000252F4C96DE0>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function _TestClientTransport.handle_request.<locals>.receive at 0x00000252F4E3FCE0>
send = <function wrap_app_handling_exceptions.<locals>.wrapped_app.<locals>.sender at 0x00000252F4EE3600>

    async def app(scope: Scope, receive: Receive, send: Send) -> None:
        request = Request(scope, receive, send)
    
        async def app(scope: Scope, receive: Receive, send: Send) -> None:
            # Starts customization
            response_awaited = False
            async with AsyncExitStack() as stack:
                scope["fastapi_inner_astack"] = stack
                # Same as in Starlette
                response = await f(request)
                await response(scope, receive, send)
                # Continues customization
                response_awaited = True
            if not response_awaited:
                raise FastAPIError(
                    "Response not awaited. There's a high chance that the "
                    "application code is raising an exception and a dependency with yield "
                    "has a block with a bare except, or a block with except Exception, "
                    "and is not raising the exception again. Read more about it in the "
                    "docs: https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-with-yield/#dependencies-with-yield-and-except"
                )
    
        # Same as in Starlette
>       await wrap_app_handling_exceptions(app, request)(scope, receive, send)

C:\Users\Filipe AtaÝde\AppData\Local\Programs\Python\Python313\Lib\site-packages\fastapi\routing.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

scope = {'app': <fastapi.applications.FastAPI object at 0x00000252F4CA5940>, 'client': ('testclient', 50000), 'endpoint': <function send_message_to_suspect at 0x00000252F4C96DE0>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function _TestClientTransport.handle_request.<locals>.receive at 0x00000252F4E3FCE0>
send = <function wrap_app_handling_exceptions.<locals>.wrapped_app.<locals>.sender at 0x00000252F4EE3600>

    async def wrapped_app(scope: Scope, receive: Receive, send: Send) -> None:
        response_started = False
    
        async def sender(message: Message) -> None:
            nonlocal response_started
    
            if message["type"] == "http.response.start":
                response_started = True
            await send(message)
    
        try:
            await app(scope, receive, sender)
        except Exception as exc:
            handler = None
    
            if isinstance(exc, HTTPException):
                handler = status_handlers.get(exc.status_code)
    
            if handler is None:
                handler = _lookup_exception_handler(exception_handlers, exc)
    
            if handler is None:
>               raise exc

C:\Users\Filipe AtaÝde\AppData\Local\Programs\Python\Python313\Lib\site-packages\starlette\_exception_handler.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

scope = {'app': <fastapi.applications.FastAPI object at 0x00000252F4CA5940>, 'client': ('testclient', 50000), 'endpoint': <function send_message_to_suspect at 0x00000252F4C96DE0>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function _TestClientTransport.handle_request.<locals>.receive at 0x00000252F4E3FCE0>
send = <function wrap_app_handling_exceptions.<locals>.wrapped_app.<locals>.sender at 0x00000252F4EE3600>

    async def wrapped_app(scope: Scope, receive: Receive, send: Send) -> None:
        response_started = False
    
        async def sender(message: Message) -> None:
            nonlocal response_started
    
            if message["type"] == "http.response.start":
                response_started = True
            await send(message)
    
        try:
>           await app(scope, receive, sender)

C:\Users\Filipe AtaÝde\AppData\Local\Programs\Python\Python313\Lib\site-packages\starlette\_exception_handler.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

scope = {'app': <fastapi.applications.FastAPI object at 0x00000252F4CA5940>, 'client': ('testclient', 50000), 'endpoint': <function send_message_to_suspect at 0x00000252F4C96DE0>, 'extensions': {'http.response.debug': {}}, ...}
receive = <function _TestClientTransport.handle_request.<locals>.receive at 0x00000252F4E3FCE0>
send = <function wrap_app_handling_exceptions.<locals>.wrapped_app.<locals>.sender at 0x00000252F4EE3C40>

    async def app(scope: Scope, receive: Receive, send: Send) -> None:
        # Starts customization
        response_awaited = False
        async with AsyncExitStack() as stack:
            scope["fastapi_inner_astack"] = stack
            # Same as in Starlette
>           response = await f(request)
                       ^^^^^^^^^^^^^^^^

C:\Users\Filipe AtaÝde\AppData\Local\Programs\Python\Python313\Lib\site-packages\fastapi\routing.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <starlette.requests.Request object at 0x00000252F4E0A2C0>

    async def app(request: Request) -> Response:
        response: Union[Response, None] = None
        file_stack = request.scope.get("fastapi_middleware_astack")
        assert isinstance(file_stack, AsyncExitStack), (
            "fastapi_middleware_astack not found in request scope"
        )
    
        # Read body and auto-close files
        try:
            body: Any = None
            if body_field:
                if is_body_form:
                    body = await request.form()
                    file_stack.push_async_callback(body.close)
                else:
                    body_bytes = await request.body()
                    if body_bytes:
                        json_body: Any = Undefined
                        content_type_value = request.headers.get("content-type")
                        if not content_type_value:
                            json_body = await request.json()
                        else:
                            message = email.message.Message()
                            message["content-type"] = content_type_value
                            if message.get_content_maintype() == "application":
                                subtype = message.get_content_subtype()
                                if subtype == "json" or subtype.endswith("+json"):
                                    json_body = await request.json()
                        if json_body != Undefined:
                            body = json_body
                        else:
                            body = body_bytes
        except json.JSONDecodeError as e:
            validation_error = RequestValidationError(
                [
                    {
                        "type": "json_invalid",
                        "loc": ("body", e.pos),
                        "msg": "JSON decode error",
                        "input": {},
                        "ctx": {"error": e.msg},
                    }
                ],
                body=e.doc,
            )
            raise validation_error from e
        except HTTPException:
            # If a middleware raises an HTTPException, it should be raised again
            raise
        except Exception as e:
            http_error = HTTPException(
                status_code=400, detail="There was an error parsing the body"
            )
            raise http_error from e
    
        # Solve dependencies and run path operation function, auto-closing dependencies
        errors: List[Any] = []
        async_exit_stack = request.scope.get("fastapi_inner_astack")
        assert isinstance(async_exit_stack, AsyncExitStack), (
            "fastapi_inner_astack not found in request scope"
        )
        solved_result = await solve_dependencies(
            request=request,
            dependant=dependant,
            body=body,
            dependency_overrides_provider=dependency_overrides_provider,
            async_exit_stack=async_exit_stack,
            embed_body_fields=embed_body_fields,
        )
        errors = solved_result.errors
        if not errors:
>           raw_response = await run_endpoint_function(
                dependant=dependant,
                values=solved_result.values,
                is_coroutine=is_coroutine,
            )

C:\Users\Filipe AtaÝde\AppData\Local\Programs\Python\Python313\Lib\site-packages\fastapi\routing.py:387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    async def run_endpoint_function(
        *, dependant: Dependant, values: Dict[str, Any], is_coroutine: bool
    ) -> Any:
        # Only called by get_request_handler. Has been split into its own function to
        # facilitate profiling endpoints, since inner functions are harder to profile.
        assert dependant.call is not None, "dependant.call must be a function"
    
        if is_coroutine:
            return await dependant.call(**values)
        else:
>           return await run_in_threadpool(dependant.call, **values)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

C:\Users\Filipe AtaÝde\AppData\Local\Programs\Python\Python313\Lib\site-packages\fastapi\routing.py:290: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

func = functools.partial(<function send_message_to_suspect at 0x00000252F4C96DE0>, session_id=1, suspect_id=1, payload=PlayerChatInput(text='Explique isso.', evidence_id=1))
args = ()
kwargs = {'payload': PlayerChatInput(text='Explique isso.', evidence_id=1), 'session_id': 1, 'suspect_id': 1}

    async def run_in_threadpool(func: Callable[P, T], *args: P.args, **kwargs: P.kwargs) -> T:
        func = functools.partial(func, *args, **kwargs)
>       return await anyio.to_thread.run_sync(func)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

C:\Users\Filipe AtaÝde\AppData\Local\Programs\Python\Python313\Lib\site-packages\starlette\concurrency.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

func = functools.partial(<function send_message_to_suspect at 0x00000252F4C96DE0>, session_id=1, suspect_id=1, payload=PlayerChatInput(text='Explique isso.', evidence_id=1))
abandon_on_cancel = False, cancellable = None, limiter = None, args = ()

    async def run_sync(
        func: Callable[[Unpack[PosArgsT]], T_Retval],
        *args: Unpack[PosArgsT],
        abandon_on_cancel: bool = False,
        cancellable: bool | None = None,
        limiter: CapacityLimiter | None = None,
    ) -> T_Retval:
        """
        Call the given function with the given arguments in a worker thread.
    
        If the ``cancellable`` option is enabled and the task waiting for its completion is
        cancelled, the thread will still run its course but its return value (or any raised
        exception) will be ignored.
    
        :param func: a callable
        :param args: positional arguments for the callable
        :param abandon_on_cancel: ``True`` to abandon the thread (leaving it to run
            unchecked on own) if the host task is cancelled, ``False`` to ignore
            cancellations in the host task until the operation has completed in the worker
            thread
        :param cancellable: deprecated alias of ``abandon_on_cancel``; will override
            ``abandon_on_cancel`` if both parameters are passed
        :param limiter: capacity limiter to use to limit the total amount of threads running
            (if omitted, the default limiter is used)
        :return: an awaitable that yields the return value of the function.
    
        """
        if cancellable is not None:
            abandon_on_cancel = cancellable
            warn(
                "The `cancellable=` keyword argument to `anyio.to_thread.run_sync` is "
                "deprecated since AnyIO 4.1.0; use `abandon_on_cancel=` instead",
                DeprecationWarning,
                stacklevel=2,
            )
    
>       return await get_async_backend().run_sync_in_worker_thread(
            func, args, abandon_on_cancel=abandon_on_cancel, limiter=limiter
        )

C:\Users\Filipe AtaÝde\AppData\Local\Programs\Python\Python313\Lib\site-packages\anyio\to_thread.py:56: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

cls = <class 'anyio._backends._asyncio.AsyncIOBackend'>
func = functools.partial(<function send_message_to_suspect at 0x00000252F4C96DE0>, session_id=1, suspect_id=1, payload=PlayerChatInput(text='Explique isso.', evidence_id=1))
args = (), abandon_on_cancel = False, limiter = None

    @classmethod
    async def run_sync_in_worker_thread(  # type: ignore[return]
        cls,
        func: Callable[[Unpack[PosArgsT]], T_Retval],
        args: tuple[Unpack[PosArgsT]],
        abandon_on_cancel: bool = False,
        limiter: abc.CapacityLimiter | None = None,
    ) -> T_Retval:
        await cls.checkpoint()
    
        # If this is the first run in this event loop thread, set up the necessary
        # variables
        try:
            idle_workers = _threadpool_idle_workers.get()
            workers = _threadpool_workers.get()
        except LookupError:
            idle_workers = deque()
            workers = set()
            _threadpool_idle_workers.set(idle_workers)
            _threadpool_workers.set(workers)
    
        async with limiter or cls.current_default_thread_limiter():
            with CancelScope(shield=not abandon_on_cancel) as scope:
                future = asyncio.Future[T_Retval]()
                root_task = find_root_task()
                if not idle_workers:
                    worker = WorkerThread(root_task, workers, idle_workers)
                    worker.start()
                    workers.add(worker)
                    root_task.add_done_callback(
                        worker.stop, context=contextvars.Context()
                    )
                else:
                    worker = idle_workers.pop()
    
                    # Prune any other workers that have been idle for MAX_IDLE_TIME
                    # seconds or longer
                    now = cls.current_time()
                    while idle_workers:
                        if (
                            now - idle_workers[0].idle_since
                            < WorkerThread.MAX_IDLE_TIME
                        ):
                            break
    
                        expired_worker = idle_workers.popleft()
                        expired_worker.root_task.remove_done_callback(
                            expired_worker.stop
                        )
                        expired_worker.stop()
    
                context = copy_context()
                context.run(sniffio.current_async_library_cvar.set, None)
                if abandon_on_cancel or scope._parent_scope is None:
                    worker_scope = scope
                else:
                    worker_scope = scope._parent_scope
    
                worker.queue.put_nowait((context, func, args, future, worker_scope))
>               return await future
                       ^^^^^^^^^^^^

C:\Users\Filipe AtaÝde\AppData\Local\Programs\Python\Python313\Lib\site-packages\anyio\_backends\_asyncio.py:2470: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WorkerThread(AnyIO worker thread, stopped daemon 18616)>

    def run(self) -> None:
        with claim_worker_thread(AsyncIOBackend, self.loop):
            while True:
                item = self.queue.get()
                if item is None:
                    # Shutdown command received
                    return
    
                context, func, args, future, cancel_scope = item
                if not future.cancelled():
                    result = None
                    exception: BaseException | None = None
                    threadlocals.current_cancel_scope = cancel_scope
                    try:
>                       result = context.run(func, *args)
                                 ^^^^^^^^^^^^^^^^^^^^^^^^

C:\Users\Filipe AtaÝde\AppData\Local\Programs\Python\Python313\Lib\site-packages\anyio\_backends\_asyncio.py:967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

session_id = 1, suspect_id = 1
payload = PlayerChatInput(text='Explique isso.', evidence_id=1)

    @router.post("/sessions/{session_id}/suspects/{suspect_id}/messages")
    def send_message_to_suspect(session_id: int, suspect_id: int, payload: PlayerChatInput):
        """
        Handles a full interrogation turn atomically.
        """
        db = SessionLocal()
        try:
            result = run_interrogation_turn(
                session_id=session_id,
                suspect_id=suspect_id,
                text=payload.text,
                evidence_id=payload.evidence_id,
                db=db
            )
            db.commit()
            return result
        except Exception as e:
            db.rollback()
>           raise e

app\api\sessions.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

session_id = 1, suspect_id = 1
payload = PlayerChatInput(text='Explique isso.', evidence_id=1)

    @router.post("/sessions/{session_id}/suspects/{suspect_id}/messages")
    def send_message_to_suspect(session_id: int, suspect_id: int, payload: PlayerChatInput):
        """
        Handles a full interrogation turn atomically.
        """
        db = SessionLocal()
        try:
>           result = run_interrogation_turn(
                session_id=session_id,
                suspect_id=suspect_id,
                text=payload.text,
                evidence_id=payload.evidence_id,
                db=db
            )

app\api\sessions.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

session_id = 1, suspect_id = 1, text = 'Explique isso.', evidence_id = 1
db = <sqlalchemy.orm.session.Session object at 0x00000252F4E5F750>

    def run_interrogation_turn(
        session_id: int,
        suspect_id: int,
        text: str,
        evidence_id: Optional[int],
        db: Session
    ) -> Dict[str, Any]:
        """
        Orchestrates a full interrogation turn in a transactional manner.
        Expects an active database session and does not commit it.
        """
    
        # 1. Player message
        player_msg = add_player_message(
            session_id=session_id,
            suspect_id=suspect_id,
            text=text,
            evidence_id=evidence_id,
            db=db
        )
    
        # 2. Evidence logic (may reveal secrets)
        revealed_secrets = []
        if evidence_id is not None:
            revealed_secrets = apply_evidence_to_suspect(
                session_id=session_id,
                suspect_id=suspect_id,
                evidence_id=evidence_id,
                db=db
            )
    
        # 3. NPC reply
>       npc_msg = add_npc_reply(
            session_id=session_id,
            suspect_id=suspect_id,
            player_message_id=player_msg["id"],
            db=db
        )

app\services\interrogation_turn_service.py:41: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

session_id = 1, suspect_id = 1, player_message_id = 1
db = <sqlalchemy.orm.session.Session object at 0x00000252F4E5F750>

    def add_npc_reply(
        session_id: int,
        suspect_id: int,
        player_message_id: int,
        db: Optional[Session] = None
    ) -> NpcChatMessageModel:
        """
        Generates an NPC reply after a player sends a message.
    
        Steps:
        1. Load suspect state (revealed secrets, closed flag, personality info)
        2. Load recent chat history
        3. Load the player message content
        4. Call the AI adapter to generate reply text
        5. Save NPC message to DB
        6. Return that DB object
        """
    
        close_db = False
        if db is None:
            db = SessionLocal()
            close_db = True
    
        try:
            # ----------------------------------------
            # 1. Load suspect state for this session
            # ----------------------------------------
            state = db.query(SessionSuspectStateModel).filter(
                SessionSuspectStateModel.session_id == session_id,
                SessionSuspectStateModel.suspect_id == suspect_id
            ).first()
    
            if not state:
                raise NotFoundError(f"Suspect {suspect_id} not part of session {session_id}.")
    
            # Load suspect model (for personality, final phrase, etc.)
            suspect = db.query(SuspectModel).filter(
                SuspectModel.id == suspect_id
            ).first()
    
            true_timeline = suspect.true_timeline or []
            lies = suspect.lies or []
    
            # ----------------------------------------
            # 2. Load chat history for this suspect/session
            # ----------------------------------------
            history_rows = db.query(NpcChatMessageModel).filter(
                NpcChatMessageModel.session_id == session_id,
                NpcChatMessageModel.suspect_id == suspect_id
            ).order_by(NpcChatMessageModel.timestamp.asc()).all()
    
            chat_history = [
                {
                    "sender": row.sender_type,
                    "text": row.text,
                    "evidence_id": row.evidence_id,
                    "timestamp": row.timestamp.isoformat()
                }
                for row in history_rows
            ]
    
            # ----------------------------------------
            # 3. Load the player message
            # ----------------------------------------
            player_msg = db.query(NpcChatMessageModel).filter(
                NpcChatMessageModel.id == player_message_id
            ).first()
    
            if not player_msg:
                raise NotFoundError(f"Player message {player_message_id} not found.")
    
            player_message_dict = {
                "text": player_msg.text,
                "evidence_id": player_msg.evidence_id
            }
    
            # ----------------------------------------
            # 4. Build suspect_state for AI
            # ----------------------------------------
            revealed_secrets = []
            if state.revealed_secret_ids:
                secrets = db.query(SecretModel).filter(
                    SecretModel.id.in_(state.revealed_secret_ids)
                ).all()
                for sc in secrets:
                    revealed_secrets.append({
                        "secret_id": sc.id,
                        "content": sc.content,
                        "is_core": sc.is_core
                    })
    
            # Hidden secrets (just for dummy AI)
            hidden_secrets = db.query(SecretModel).filter(
                SecretModel.suspect_id == suspect_id
            ).all()
    
            hidden_list = [
                {"secret_id": sc.id, "content": sc.content, "is_core": sc.is_core}
                for sc in hidden_secrets
                if sc.id not in state.revealed_secret_ids
            ]
    
            suspect_state = {
                "suspect_id": suspect_id,
                "name": suspect.name if suspect else "O suspeito",
                "personality": suspect.backstory or "neutro",
                "revealed_secrets": revealed_secrets,
                "hidden_secrets": hidden_list,
                "is_closed": state.is_closed,
                "final_phrase": (
                    suspect.final_phrase
                    if suspect and suspect.final_phrase
                    else "Jß falei tudo que sabia."
                )
            }
    
            # ----------------------------------------
            # Load scenario
            # ----------------------------------------
    
            session = (
                db.query(SessionModel)
                .filter(SessionModel.id == session_id)
                .first()
            )
    
            if not session:
                raise NotFoundError(f"Session {session_id} not found")
    
            scenario = (
                db.query(ScenarioModel)
                .filter(ScenarioModel.id == session.scenario_id)
                .first()
            )
    
            if not scenario:
                raise NotFoundError("Scenario not found for session")
    
            # ----------------------------------------
            # Build pressure points (MVP)
            # ----------------------------------------
            pressure_points = [
                {
                    "evidence_id": msg["evidence_id"],
                    "text": msg["text"]
                }
                for msg in chat_history
                if msg.get("evidence_id") is not None
            ]
    
            # ----------------------------------------
            # Call AI adapter
            # ----------------------------------------
            npc_context = build_npc_context(
                scenario=scenario,
                suspect=suspect,
                suspect_state=suspect_state,
                revealed_secrets=revealed_secrets,
                pressure_points=pressure_points,
            )
    
            reply_text = ai.generate_reply(
                suspect_state=suspect_state,
                npc_context=npc_context,
                chat_history=chat_history,
                player_message=player_message_dict
            )
    
            # ----------------------------------------
            # 6. Save NPC message
            # ----------------------------------------
            npc_msg = NpcChatMessageModel(
                session_id=session_id,
                suspect_id=suspect_id,
                sender_type="npc",
                text=reply_text
            )
    
            db.add(npc_msg)
            db.flush()
            db.refresh(npc_msg)
    
>           if close_session:
               ^^^^^^^^^^^^^
E           NameError: name 'close_session' is not defined

app\services\chat_service.py:301: NameError
---------------------------- Captured stdout call -----------------------------
[loader] Scenario 'O Caso do Escrit¾rio Trancado' loaded successfully.
[session] Session 1 created for scenario 1
============================== warnings summary ===============================
app\main.py:18
  D:\Python Projetos\detective_ai\app\main.py:18: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    @app.on_event("startup")

C:\Users\Filipe AtaÝde\AppData\Local\Programs\Python\Python313\Lib\site-packages\fastapi\applications.py:4574
  C:\Users\Filipe AtaÝde\AppData\Local\Programs\Python\Python313\Lib\site-packages\fastapi\applications.py:4574: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    return self.router.on_event(event_type)

tests/test_happy_path_flow.py::test_happy_path_piloto_end_to_end
  D:\Python Projetos\detective_ai\app\services\scenario_loader.py:86: PydanticDeprecatedSince20: The `dict` method is deprecated; use `model_dump` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    lies=[lie.dict() for lie in s.lies] if s.lies else None

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ===========================
FAILED tests/test_happy_path_flow.py::test_happy_path_piloto_end_to_end - Nam...
======================== 1 failed, 3 warnings in 1.97s ========================
